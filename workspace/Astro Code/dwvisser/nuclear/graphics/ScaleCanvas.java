/***************************************************************
 * Nuclear Simulation Java Class Libraries
 * Copyright (C) 2003 Yale University
 * 
 * Original Developer
 *     Dale Visser (dale@visser.name)
 * 
 * OSI Certified Open Source Software
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the University of Illinois/NCSA 
 * Open Source License.
 * 
 * This program is distributed in the hope that it will be 
 * useful, but without any warranty; without even the implied 
 * warranty of merchantability or fitness for a particular 
 * purpose. See the University of Illinois/NCSA Open Source 
 * License for more details.
 * 
 * You should have received a copy of the University of 
 * Illinois/NCSA Open Source License along with this program; if 
 * not, see http://www.opensource.org/
 **************************************************************/
/*
 * SpectrumCanvas.java
 *
 * Created on October 23, 2001, 4:03 PM
 */

package dwvisser.nuclear.graphics;
import java.awt.*;
import java.awt.geom.*;
import java.awt.font.*;
import javax.swing.*;

/**
 *
 * @author  dwvisser
 */
public class ScaleCanvas extends JPanel {

    private RadiusRange range;
	private final Dimension screen=Toolkit.getDefaultToolkit().getScreenSize();
    
    /** Creates new form SpectrumCanvas */
    public ScaleCanvas(RadiusRange rr) {
        initComponents();
        range=rr;
        setBackground(Color.white);
        setBorder(BorderFactory.createLineBorder(Color.blue,1));
        setOpaque(true);
        setPreferredSize(new Dimension(500,HEIGHT));
        final Dimension min=new Dimension(200,HEIGHT);
        final Dimension max=new Dimension(screen.width,HEIGHT);
        setMaximumSize(max);
        setMinimumSize(min);
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        setLayout(new java.awt.BorderLayout());

    }//GEN-END:initComponents

    public void paintComponent(Graphics graphics) {
        final Graphics2D g2=(Graphics2D)graphics;
        final FontRenderContext frc=g2.getFontRenderContext();
        final Dimension d=getSize();
        double length=range.getRhoMax()-range.getRhoMin();
        g2.setPaint(Color.darkGray);
        double lastXcoord=d.width;
        final int [] radii = ticksLinear();
        for (int i=radii.length-1; i>=0;i--){
            if (radii[i] > range.getRhoMin() && radii[i] < range.getRhoMax()){
            	final String label=String.valueOf(radii[i]);
                final double xfrac = (radii[i]-range.getRhoMin())/length;
                final double xcoord = xfrac*d.width;
                final double diff = lastXcoord-xcoord;
                Rectangle2D stringBounds=g2.getFont().getStringBounds(label,frc);
                final double lineBottom;
                if (diff >= stringBounds.getWidth()) {
                    g2.drawString(label,(float)xcoord,(float)(d.height-
                    stringBounds.getHeight()/10));
                    lastXcoord=xcoord;
                    lineBottom = d.height-stringBounds.getHeight();
                } else {
                    lineBottom = d.height-2*stringBounds.getHeight();
                }
                final Line2D line = new Line2D.Double(xcoord,0,xcoord,lineBottom);
                g2.draw(line);
            }
        }
    }  
    
	/** 
	 * Figure out ticks for linear scale.    
	 */
	private int[] ticksLinear() {
		double lowerLimit=range.getRhoMin();
		double upperLimit=range.getRhoMax();
		final int tickSpace = tickSpace(lowerLimit, upperLimit);
		final int tickMin = tickMin(lowerLimit, tickSpace);
		final int tickMax = tickMax(upperLimit, tickSpace);
		int numTicks = (tickMax - tickMin) / tickSpace + 1;
		int tempTick[] = new int[numTicks];
		for (int i = 0; i < numTicks; i++) {
			tempTick[i] = tickMin + i * tickSpace;
		}
		return tempTick;
	}
	
	private static final int MIN_NUMBER_TICKS = 10;
	private static final int MAXIMUM_COUNTS = 1000000000;
	
	/** 
	 *  Tick spacing for linear scale.   
	 */
	private int tickSpace(double lowerLimit, double upperLimit) {
		final double range = upperLimit - lowerLimit;
		int tickSpace = 1;
		//loop trying succesively bigger tick spacing
		for (int i = 1; i < MAXIMUM_COUNTS; i *= 10) {
			tickSpace = i;
			if ((tickSpace * MIN_NUMBER_TICKS) >= range){
				break;
			}
			tickSpace = i * 2;
			if ((tickSpace * MIN_NUMBER_TICKS) >= range){
				break;
			}
			tickSpace = i * 5;
			if ((tickSpace * MIN_NUMBER_TICKS) >= range){
				break;
			}
		}
		return tickSpace;
	}
	
	/** 
	 * Placement of minimum tick for linear         
	 */
	private int tickMin(double lowerLimit, int tickSpace) {
		int tempTickMin;
		if ((lowerLimit % tickSpace) == 0) { //lower limit is a tick
			tempTickMin = (int)Math.ceil(lowerLimit);
		} else { //tick just above lower limit
			tempTickMin = ((int)lowerLimit / tickSpace + 1) * tickSpace;
			//round down and add one
		}

		if ((lowerLimit <= 0)
			&& (tempTickMin > 0)) { //do we need to make zero a tick
			tempTickMin = 0;
		}
		return tempTickMin;
	}
	
	/** 
	 * Placement of maximum tick for linear         
	 */
	private int tickMax(double upperLimit, int tickSpace) {
		int tempTickMax;
		if ((upperLimit % tickSpace) == 0) { //upper limit is a tick
			tempTickMax = (int)Math.floor(upperLimit);
		} else {
			tempTickMax = ((int)upperLimit / tickSpace) * tickSpace;
			//round down for last tick
		}
		return tempTickMax;
	}
	
	private final static int HEIGHT=25;
  
  	public JPanel getScalePanel(){
		final JPanel rval = new JPanel(new FlowLayout(FlowLayout.RIGHT));
		final JLabel label=new JLabel("\u03c1 [cm]");
		rval.setPreferredSize(new Dimension(label.getPreferredSize().width,HEIGHT));
		rval.setMinimumSize(new Dimension(0,HEIGHT));
		rval.setMaximumSize(new Dimension(screen.width,HEIGHT));
		rval.add(label);
		return rval;
  	}
}
